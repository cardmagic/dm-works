
Configuration:
  Setup creates and stores a Database proxy

Database proxy:
  Transparent Connection status
  Can Issue Database Transactions
  
Session
  Ties to simplified DatabaseInterface
  Ties to loaded Models
  Flushes discoverable work on close
  
Saves:
  Uses a Session
    Generates the UnitsOfWork
    Passes Each to the QueryGenerator
    Uses Database Dialects
    Executes queries against given Database proxy
  
Models:
  Keep reference to Session Proxy
  Store own UnitOfWork so sessions can be agnostic

IdentityMap:
  Database Specific WeakRefHash

Finder:
  Uses a Session
    Delegates to Loader
      Checks IdentityMap
      Delegates to QueryGenerator
      Double-checks IdentityMap
      Materializes Object(s) and adds to IdentityMap
      Returns Results
      
So a Session is tied to a single Database, and is largely a UnitOfWork generator. All other work is proxied out.

The Session does not manage the Database connection, it only consumes it. The Database proxy is in charge of
managing actual connections and database transactions.

Sessions can easily be merged since they don't track state on their own.

So each Database could have an associated singleton-ish Session then... hmmm...

It should not be possible to "jump" between sessions with an object. This makes multiple databases much simpler,
  but means attribute synchronization would have to be manual. Which isn't a big deal really.